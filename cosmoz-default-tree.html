<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="cosmoz-tree.html">

<!--
Navigator through object with treelike datastructure and default settings.

@demo demo/index.html
-->
<script>
	'use strict';

	// Needed for iron-component-page.
	Polymer({ is: 'cosmoz-default-tree' });

	window.Cosmoz = window.Cosmoz || {};

	function _objectValues(obj) {
		if (!obj) {
			return;
		}
		return Object.keys(obj).map(function (key) {
			return obj[key];
		});
	}

	/**
	 * Cosmoz.DefaultTree
	 *
	 * @constructor
	 *
	 * @param {object} treeData (The tree object.)
	 * @param {object} options (Tree options.)
	 * @param {string} options.childProperty ["children"] (The name of the property a search should be based on. e.g. "name")
	 * @param {string} options.propertyName ["name"] (The name of the property a search should be based on. e.g. "name")
	 * @param {string} options.pathStringSeparator ["/"] (The string the path should get separated with.)
	 * @param {string} options.pathLocatorSeparator ["."] (The string which separates the path segments of a path locator.)
	*/
	Cosmoz.DefaultTree = function (treeData, options) {
		Cosmoz.Tree.apply(this, arguments);
		this._treeData = treeData;
		this._roots = _objectValues(treeData);

		options = options || {};
		this.pathLocatorSeparator = options.pathLocatorSeparator || '.';
		this.pathStringSeparator = options.pathStringSeparator || '/';
		this.childProperty = options.childProperty || 'children';
		this.searchProperty = options.searchProperty || 'name';
	};

	Cosmoz.DefaultTree.prototype = Object.create(Cosmoz.Tree.prototype);

	/**
	 * Searches a (multi root) node and matches nodes based on a property and a value.
	 * @return {object} - The first found node.
	 * @param {string} propertyValue (The value of the property the match should be based on. e.g. "Peter")
	 * @param {string} propertyName (The name of the property the match should be based on. e.g. "name")
	 * @param {array} nodes [this._roots] (The objects the search should be based on.)
	 */
	Cosmoz.DefaultTree.prototype.getNodeByProperty = function (propertyValue, propertyName, nodes) {
		if (propertyValue === undefined) {
			return;
		}
		// Defaults
		nodes = nodes || this._roots;
		propertyName = propertyName || this.searchProperty;

		return this.findNode(propertyValue, propertyName, nodes);
	};

	/**
	 * Searches a (multi root) node and matches nodes based on a property and a value.
	 * @return {array} - All found nodes.
	 * @param {string} propertyName [this.searchProperty] (The name of the property the match should be based on. e.g. "name")
	 * @param {string} propertyValue (The value of the property the match should be based on. e.g. "Peter")
	 * @param {boolean} exact [true] (If the search should be executed exact or flaw. true wouldn't match "Pet")
	 * @param {object} nodes [this._treeData] (The nodes the search should be based on.)
	*/
	Cosmoz.DefaultTree.prototype.searchNodes = function (propertyValue, nodes, exact, propertyName) {
		var options = {
			propertyName: propertyName || this.searchProperty,
			exact: exact !== undefined ? exact : true,
			firstHitOnly: false
		};
		return this._searchNodes(propertyValue, options, nodes);
	};

	/**
	 * Searches a (multi root) node and matches nodes based on a property and a value.
	 * @return {object} - The first found node.
	 * @param {string} propertyValue (The value of the property the match should be based on. e.g. "Peter")
	 * @param {string} propertyName [this.searchProperty] (The name of the property the match should be based on. e.g. "name")
	 * @param {object} nodes [this._treeData] (The nodes the search should be based on.)
	*/
	Cosmoz.DefaultTree.prototype.findNode = function (propertyValue, propertyName, nodes) {
		var options = {
			propertyName: propertyName || this.searchProperty,
			exact: true,
			firstHitOnly: true
		};
		return this._searchNodes(propertyValue, options, nodes).shift();
	};

	/**
	 * Searches a (multi root) node and matches nodes based on a property and a value.
	 * @return {array} - The found node(s).
	 * @param {string} propertyValue (The value of the property the match should be based on. e.g. "Peter")
	 * @param {object} options (Matching options)
	 * @param {string} options.propertyName (The name of the property the match should be based on. e.g. "name")
	 * @param {boolean} options.exact [false] (If the search should be executed exact or fuzzy. true wouldn't match "Pet")
	 * @param {boolean} options.firstHitOnly [false] (If the search should only return the first found node.)
	 * @param {object} nodes [this._roots] (The nodes the search should be based on.)
	*/
	Cosmoz.DefaultTree.prototype._searchNodes = function (propertyValue, options, nodes) {
		var results = [];

		// Defaults
		nodes = nodes || this._roots;

		nodes.some(function (node) {
			results = results.concat(this.search(node, propertyValue, options));
			return options.firstHitOnly && results.length > 0;
		}, this);

		return results;
	};

	/**
	 * Returns the node of a given path.
	 * @return {object}
	 * @param {string} pathLocator (The string which describes the path. e.g. "1.2.9")
	 * @param {object} nodeObj [this._treeData] (The object the search should be based on.)
	 * @param {string} pathLocatorSeparator [this.pathLocatorSeparator] (The string which separates the path. e.g ".")
	*/
	Cosmoz.DefaultTree.prototype.getNodeByPathLocator = function (pathLocator, nodeObj, pathLocatorSeparator) {
		if (!pathLocator) {
			return this._roots;
		}

		// Defaults
		nodeObj = nodeObj || this._treeData;
		pathLocatorSeparator = pathLocatorSeparator || this.pathLocatorSeparator;

		var	pathNodes = this.getPathNodes(pathLocator, nodeObj, pathLocatorSeparator);
		return pathNodes && pathNodes.pop();
	};

	/**
	 * Returns the nodes on a given path.
	 * A valid path 1.2.3 should return the items [1, 2, 3]
	 * - path 1.2.3.3 should return [1, 2, 3, undefined]
	 * - path 0.1.2.3 should return [1, 2, 3]
	 * - path 0.1.5.3 should return [1, undefined, undefined]
	 * @return {array}
	 * @param {string} pathLocator (The string which describes the path. e.g. "1.2.9")
	 * @param {object} nodeObj [this._treeData] (The object the search should be based on.)
	 * @param {string} pathLocatorSeparator [this.pathLocatorSeparator] (The string which separates the path.)
	*/
	Cosmoz.DefaultTree.prototype.getPathNodes = function (pathLocator, nodeObj, pathLocatorSeparator) {
		if (!pathLocator) {
			return this._roots;
		}

		// Defaults
		pathLocatorSeparator = pathLocatorSeparator || this.pathLocatorSeparator;

		var nodeObj = nodeObj || this._treeData,
			results = [];

		// Getting path nodes
		Object.keys(nodeObj).forEach(function (nodeKey) {
			var node = {};
			node[nodeKey] = nodeObj[nodeKey];
			var result = this._getPathNodes(pathLocator, node, pathLocatorSeparator);
			results.push(result);
		}, this);

		return results.sort(this._sortPathNodes)[0];
	},

	Cosmoz.DefaultTree.prototype._sortPathNodes = function (a, b) {
		var adef,
			bdef,
			countTypes = function (arr) {
				return arr.reduce(function (prev, curr) {
					return (prev[typeof curr] = ++prev[typeof curr] || 1, prev);
				}, {});
			},
			undefinedCountA = countTypes(a)['undefined'] || 0,
			undefinedCountB = countTypes(b)['undefined'] || 0;
		
		// If equal amount of undefined values, sort via array length
		// of the defined values in the array.
		if (undefinedCountA === undefinedCountB) {
			adef = a.filter(function (n) { return n; });
			bdef = b.filter(function (n) { return n; });
			return adef.length > bdef.length ? -1 : 1;
		}

		// Reverse sort by undefined values in array
		if (undefinedCountB > undefinedCountA) {
			if (a.length > 0) {
				return -1;
			} else {
				// Corner case, a is empty and b is not.
				return b.length > 0 ? 1 : -1;
			}
		} else {
			return -1;
		}
	},

	Cosmoz.DefaultTree.prototype._getPathNodes = function (pathLocator, nodeObj, pathLocatorSeparator) {
		if (!pathLocator) {
			return this._roots;
		}

		// Defaults
		pathLocatorSeparator = pathLocatorSeparator || this.pathLocatorSeparator;

		var path = pathLocator.split(pathLocatorSeparator),
			pathSegment = nodeObj || this._treeData,
			nodes = [],
			node;

		// Get the nodes on the path
		path.some(function (nodeKey) {
			node = pathSegment[nodeKey];
			
			if (node) {
				nodes.push(node);
			} else {
				return nodes.length !== 0;
			}

			if (this.hasChildren(node)) {
				pathSegment = node[this.childProperty];
			} else {
				return true;
			}
		}, this);

		return nodes;
	},

	/**
	 * Returns a string which describes the path of a node (found by its path locator).
	 * @return {string} e.g. home/computer/desktop
	 * @param {string} pathLocator (The string which describes the path. e.g. "1.2.9")
	 * @param {string} pathProperty (The property of a node on which the path should be build on. e.g "location" with node = {"location": "home", ..})
	 * @param {string} pathStringSeparator [this.pathStringSeparator] (The string the path should get separated with.)
	 * @param {string} pathLocatorSeparator [this.pathLocatorSeparator] (The string which separates the path segments of pathLocator.)
	*/
	Cosmoz.DefaultTree.prototype.getPathString = function (pathLocator, pathProperty, pathStringSeparator, pathLocatorSeparator) {
		// Defaults
		pathProperty = pathProperty || this.searchProperty;
		pathLocatorSeparator = pathLocatorSeparator || this.pathLocatorSeparator;
		pathStringSeparator = pathStringSeparator || this.pathStringSeparator;

		var pathNodes = this.getPathNodes(pathLocator, this._treeData, pathLocatorSeparator);

		if (!pathNodes) {
			return;
		}

		return pathNodes.map(function (node) {
			return node[pathProperty];
		}).join(pathStringSeparator);
	};

	/**
	 * Returns a string which describes the path of a node (found by a node's property and value).
	 * @return {string} e.g. home/computer/desktop
	 * @param {string} propertyValue (The value of the property the match should be based on. e.g. "Peter")
	 * @param {string} propertyName (The name of the property the match should be based on. e.g. "name")
	 * @param {string} pathProperty (The property of a node on which the path should be build on. e.g "location" if node = {"location": "home"})
	 * @param {string} pathStringSeparator [this.pathStringSeparator] (The string the path should get separated with.)
	 * @param {string} pathLocatorSeparator [this.pathLocatorSeparator] (The string which separates the path. e.g ".")
	*/
	Cosmoz.DefaultTree.prototype.getPathStringByProperty = function (propertyValue, propertyName, pathProperty, pathStringSeparator, pathLocatorSeparator) {
		if (propertyValue === undefined) {
			return;
		}

		// Defaults
		pathProperty = pathProperty || this.searchProperty;
		propertyName = propertyName || this.searchProperty;
		pathLocatorSeparator = pathLocatorSeparator || this.pathLocatorSeparator;
		pathStringSeparator = pathStringSeparator || this.pathStringSeparator;

		if (propertyName === 'pathLocator') {
			return this.getPathString(propertyValue, pathProperty, pathStringSeparator, pathLocatorSeparator);
		}

		var node = this.getNodeByProperty(propertyValue, propertyName);

		if (node) {
			return this.getPathString(node.pathLocator || node.path, pathProperty);
		}
	};

	/**
	 * Returns an Object or an Array representing the children of a node.
	 */
	Cosmoz.DefaultTree.prototype.getChildren = function (node) {
		if (!node) {
			return;
		}
		return _objectValues(node[this.childProperty]);
	};

	/**
	 * Returns true if a node has children.
	 */
	Cosmoz.DefaultTree.prototype.hasChildren = function (node) {
		if (!node) {
			return false;
		}
		var children = this.getChildren(node);
		return children && children.length > 0;
	};

	/**
	 * Returns the property of a Node based on a given property name.
	 */
	Cosmoz.DefaultTree.prototype.getProperty = function (node, propertyName) {
		if (!node || !propertyName) {
			return;
		}
		return node[propertyName];
	};

</script>