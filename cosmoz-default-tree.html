<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="cosmoz-tree.html">

<!--
Navigator through object with treelike datastructure and default settings.

@demo demo/index.html
-->
<script>
	'use strict';

	Polymer({ is: 'cosmoz-default-tree' }); // Needed for iron-component-page.

	window.Cosmoz = window.Cosmoz || {};

	function _objectValues(obj) {
		if (!obj) {
			return;
		}
		return Object.keys(obj).map(function (key) {
			return obj[key];
		});
	}

	/**
	 * Cosmoz.DefaultTree
	 *
	 * @constructor
	 *
	 * @param {Object} treeData (The tree object.)
	 * @param {Object} options (Tree options.)
	 * @param {String} options.childProperty ["children"] (The name of the property a search should be based on. e.g. "name")
	 * @param {String} options.propertyName ["name"] (The name of the property a search should be based on. e.g. "name")
	 * @param {String} options.pathStringSeparator ["/"] (The string the path should get separated with.)
	 * @param {String} options.pathLocatorSeparator ["."] (The string which separates the path segments of a path locator.)
	*/
	Cosmoz.DefaultTree = function (treeData, options) {
		Cosmoz.Tree.apply(this, arguments);
		this._treeData = treeData;
		this._roots = _objectValues(treeData);

		/* eslint-disable no-param-reassign */
		options = options || {};
		/* eslint-enable no-param-reassign */
		this.pathLocatorSeparator = options.pathLocatorSeparator || '.';
		this.pathStringSeparator = options.pathStringSeparator || '/';
		this.childProperty = options.childProperty || 'children';
		this.searchProperty = options.searchProperty || 'name';
	};

	Cosmoz.DefaultTree.prototype = Object.create(Cosmoz.Tree.prototype);

	/**
	 * Searches a (multi root) node and matches nodes based on a property and a value.
	 * @returns {Object} - The first found node.
	 * @param {String} propertyValue (The value of the property the match should be based on. e.g. "Peter")
	 * @param {String} propertyName (The name of the property the match should be based on. e.g. "name")
	 * @param {Array} nodes [this._roots] (The objects the search should be based on.)
	 */
	Cosmoz.DefaultTree.prototype.getNodeByProperty = function (propertyValue, propertyName = this.searchProperty, nodes = this._roots) {
		if (propertyValue === undefined) {
			return;
		}

		return this.findNode(propertyValue, propertyName, nodes);
	};

	/**
	 * Searches a (multi root) node and matches nodes based on a property and a value.
	 * @returns {Array} - All found nodes.
	 * @param {String} propertyValue (The value of the property the match should be based on. e.g. "Peter")
	 * @param {Object} nodes [this._treeData] (The nodes the search should be based on.)
	 * @param {Boolean} exact [true] (If the search should be executed exact or flaw. true wouldn't match "Pet")
	 * @param {String} propertyName [this.searchProperty] (The name of the property the match should be based on. e.g. "name")
	*/
	Cosmoz.DefaultTree.prototype.searchNodes = function (propertyValue, nodes, exact, propertyName = this.searchProperty) {
		var options = {
			propertyName: propertyName,
			exact: exact !== undefined ? exact : true,
			firstHitOnly: false
		};
		return this._searchNodes(propertyValue, options, nodes);
	};

	/**
	 * Searches a (multi root) node and matches nodes based on a property and a value.
	 * @returns {Object} - The first found node.
	 * @param {String} propertyValue (The value of the property the match should be based on. e.g. "Peter")
	 * @param {String} propertyName [this.searchProperty] (The name of the property the match should be based on. e.g. "name")
	 * @param {Object} nodes [this._treeData] (The nodes the search should be based on.)
	*/
	Cosmoz.DefaultTree.prototype.findNode = function (propertyValue, propertyName = this.searchProperty, nodes) {
		var options = {
			propertyName: propertyName,
			exact: true,
			firstHitOnly: true
		};
		return this._searchNodes(propertyValue, options, nodes).shift();
	};

	/**
	 * Searches a (multi root) node and matches nodes based on a property and a value.
	 * @returns {Array} - The found node(s).
	 * @param {String} propertyValue (The value of the property the match should be based on. e.g. "Peter")
	 * @param {Object} options (Matching options)
	 * @param {String} options.propertyName (The name of the property the match should be based on. e.g. "name")
	 * @param {Boolean} options.exact [false] (If the search should be executed exact or fuzzy. true wouldn't match "Pet")
	 * @param {Boolean} options.firstHitOnly [false] (If the search should only return the first found node.)
	 * @param {Object} nodes [this._roots] (The nodes the search should be based on.)
	*/
	Cosmoz.DefaultTree.prototype._searchNodes = function (propertyValue, options, nodes = this._roots) {
		var results = [];

		nodes.some(function (node) {
			results = results.concat(this.search(node, propertyValue, options));
			return options.firstHitOnly && results.length > 0;
		}, this);

		return results;
	};

	/**
	 * Returns the node of a given path.
	 * @returns {Object} The node object
	 * @param {String} pathLocator (The string which describes the path. e.g. "1.2.9")
	 * @param {Object} nodeObj [this._treeData] (The object the search should be based on.)
	 * @param {String} pathLocatorSeparator [this.pathLocatorSeparator] (The string which separates the path. e.g ".")
	*/
	Cosmoz.DefaultTree.prototype.getNodeByPathLocator = function (pathLocator, nodeObj = this._treeData, pathLocatorSeparator = this.pathLocatorSeparator) {
		if (!pathLocator) {
			return this._roots;
		}

		var	pathNodes = this.getPathNodes(pathLocator, nodeObj, pathLocatorSeparator);
		return pathNodes && pathNodes.pop();
	};

	/**
	 * Returns the nodes on a given path.
	 * A valid path 1.2.3 should return the items [1, 2, 3]
	 * - path 1.2.3.3 should return [1, 2, 3, undefined]
	 * - path 0.1.2.3 should return [1, 2, 3]
	 * - path 0.1.5.3 should return [1, undefined, undefined]
	 * @returns {Array} The node array
	 * @param {String} pathLocator (The string which describes the path. e.g. "1.2.9")
	 * @param {Object} nodeObj [this._treeData] (The object the search should be based on.)
	 * @param {String} pathLocatorSeparator [this.pathLocatorSeparator] (The string which separates the path.)
	*/
	Cosmoz.DefaultTree.prototype.getPathNodes = function (pathLocator, nodeObj, pathLocatorSeparator) {
		var tree = nodeObj || this._treeData;

		if (!pathLocator) {
			return tree;
		}

		return Object.keys(tree)
			.map(function (key) {
				var subTree = {};
				subTree[key] = tree[key];
				return this._getPathNodes(pathLocator, subTree, pathLocatorSeparator);
			}, this)
			.filter(function (item) {
				return item && item.length > 0;
			})
			.sort(function (a, b) {
				var undefCounter = function (item) {
						return item === undefined;
					},
					defCounter = function (item) {
						return item;
					},
					aUndefCount = a.filter(undefCounter).length,
					bUndefCount = b.filter(undefCounter).length,
					aDefCount = a.filter(defCounter).length,
					bDefCount = b.filter(defCounter).length;

				if (aUndefCount < bUndefCount) {
					return -1;
				}
				if (aUndefCount > bUndefCount) {
					return 1;
				}
				if (aDefCount < bDefCount) {
					return 1;
				}
				if (aDefCount > bDefCount) {
					return -1;
				}
				return 0;
			})[0];
	};

	Cosmoz.DefaultTree.prototype._getPathNodes = function (pathLocator, nodeObj, pathLocatorSeparator = this.pathLocatorSeparator) {
		var path = pathLocator.split(pathLocatorSeparator),
			pathSegment = nodeObj || this._treeData,
			nodes,
			node;

		// Get the nodes on the path
		nodes = path.map(function (nodeKey) {
			if (!pathSegment) {
				return;
			}
			node = pathSegment[nodeKey];
			if (node) {
				pathSegment = node[this.childProperty];
			}
			return node;
		}, this);

		// Filter out undefined items of the start
		while (nodes.length > 0 && nodes[0] === undefined) {
			nodes.shift();
		}

		return nodes;
	};

	/**
	 * Returns a string which describes the path of a node (found by its path locator).
	 * @returns {String} e.g. home/computer/desktop
	 * @param {String} pathLocator (The string which describes the path. e.g. "1.2.9")
	 * @param {String} pathProperty (The property of a node on which the path should be build on. e.g "location" with node = {"location": "home", ..})
	 * @param {String} pathStringSeparator [this.pathStringSeparator] (The string the path should get separated with.)
	 * @param {String} pathLocatorSeparator [this.pathLocatorSeparator] (The string which separates the path segments of pathLocator.)
	*/
	Cosmoz.DefaultTree.prototype.getPathString = function (pathLocator, pathProperty = this.searchProperty, pathStringSeparator = this.pathStringSeparator, pathLocatorSeparator = this.pathLocatorSeparator) {
		var pathNodes = this.getPathNodes(pathLocator, this._treeData, pathLocatorSeparator);

		if (!pathNodes) {
			return;
		}

		return pathNodes.map(function (node) {
			return node[pathProperty];
		}).join(pathStringSeparator);
	};

	/**
	 * Returns a string which describes the path of a node (found by a node's property and value).
	 * @returns {String} e.g. home/computer/desktop
	 * @param {String} propertyValue (The value of the property the match should be based on. e.g. "Peter")
	 * @param {String} propertyName (The name of the property the match should be based on. e.g. "name")
	 * @param {String} pathProperty (The property of a node on which the path should be build on. e.g "location" if node = {"location": "home"})
	 * @param {String} pathStringSeparator [this.pathStringSeparator] (The string the path should get separated with.)
	 * @param {String} pathLocatorSeparator [this.pathLocatorSeparator] (The string which separates the path. e.g ".")
	*/
	Cosmoz.DefaultTree.prototype.getPathStringByProperty = function (propertyValue, propertyName = this.searchProperty, pathProperty = this.searchProperty, pathStringSeparator = this.pathStringSeparator, pathLocatorSeparator =  this.pathLocatorSeparator) {
		if (propertyValue === undefined) {
			return;
		}

		if (propertyName === 'pathLocator') {
			return this.getPathString(propertyValue, pathProperty, pathStringSeparator, pathLocatorSeparator);
		}

		var node = this.getNodeByProperty(propertyValue, propertyName);

		if (node) {
			return this.getPathString(node.pathLocator || node.path, pathProperty);
		}
	};

	/**
	 * Returns an Object or an Array representing the children of a node.
	 * @param {Object} node The object to return children from
	 * @returns {Object|Array} The node's children
	 */
	Cosmoz.DefaultTree.prototype.getChildren = function (node) {
		if (!node) {
			return;
		}
		return _objectValues(node[this.childProperty]);
	};

	/**
	 * Returns true if a node has children.
	 * @param {Object} node The object to get children from
	 * @returns {Boolean} True if node has children
	 */
	Cosmoz.DefaultTree.prototype.hasChildren = function (node) {
		if (!node) {
			return false;
		}
		var children = this.getChildren(node);
		return children && children.length > 0;
	};

	/**
	 * Returns the property of a Node based on a given property name.
	 * @param {Object} node The object to get property from
	 * @param {String} propertyName The name of property
	 * @returns {*} The value of the property
	 */
	Cosmoz.DefaultTree.prototype.getProperty = function (node, propertyName) {
		if (!node || !propertyName) {
			return;
		}
		return node[propertyName];
	};

</script>
